:basedir: ../../..
include::{basedir}/_common.adoc[]

[[chapter:topic-based-messaging]]
== Topic-Based Messaging
This chapter introduces the topic-based communication for exchanging data and sending events between micro applications.

[.chapter-toc]
****
[.chapter-title]
In this Chapter

- <<chapter:topic-based-messaging:what-is-topic-based-messaging>>
- <<chapter:topic-based-messaging:publishing-a-message>>
- <<chapter:topic-based-messaging:receiving-messages>>
- <<chapter:topic-based-messaging:wildcard-subscription>>
- <<chapter:topic-based-messaging:publishing-a-retained-message>>
- <<chapter:topic-based-messaging:publishing-a-message-with-headers>>
- <<chapter:topic-based-messaging:request-response-message-exchange-pattern>>

****

'''

[[chapter:topic-based-messaging:what-is-topic-based-messaging]]
[discrete]
=== What is Topic-Based Messaging?
Topic-based messaging allows publishing a message to a topic, which then is transported to consumers subscribed to the topic. Topics are case-sensitive and consist of one or more segments, each separated by a forward slash. When publishing a message to a topic, the topic must be exact, thus not contain wildcards. Messages published to a topic are transported to all consumers subscribed to the topic. Consumers, on the other hand, can subscribe to multiple topics simultaneously by using wildcard segments in the topic.

[[chapter:topic-based-messaging:publishing-a-message]]
[discrete]
=== Publishing a Message
When publishing a message, the message is transported to all consumers subscribed to the topic. The topic must be exact, thus not contain wildcards. Optionally, you can pass options to control how to publish the message or set message headers. Transfer data to be carried along with the message (i.e. the message body) can be any object which is serializable with the _Structured Clone Algorithm_.

The following code snippet shows how to publish a message to a topic destination.

[source,typescript]
----
include::topic-based-communication.snippets.ts[tags=publish]
----
<1> Specifies the topic where to publish the message to.
<2> Looks up the  `MessageClient` from the bean manager and publishes the message.

NOTE: The method to publish a message returns a Promise that resolves when dispatched the message, or that rejects if the message broker rejected the message.

[[chapter:topic-based-messaging:receiving-messages]]
[discrete]
=== Receiving Messages
A microfrontend can receive messages published to a topic as following.

[source,typescript]
----
include::topic-based-communication.snippets.ts[tags=subscribe]
----
<1> Specifies the topic which to observe.
<2> Prints the body of the received message to the console, which is `22 °C` in this example.

[[chapter:topic-based-messaging:wildcard-subscription]]
[discrete]
=== Subscribing to Multiple Topics Simultaneously
A microfrontend can subscribe to multiple topics simultaneously by using wildcard segments in the topic. If a segment begins with a colon (`:`), then the segment acts as a placeholder for any segment value. Substituted segment values are then available via the `params` property of the received message.

For example, subscribing to the topic `myhome/:room/temperature` receives messages published to the topics `myhome/kitchen/temperature` and `myhome/livingroom/temperature`.

[source,typescript]
----
include::topic-based-communication.snippets.ts[tags=subscribe-with-wildcard-segments]
----
<1> Specifies the topic which to observe; the second segment `:room` is a wildcard segment that matches any value (colon syntax).
<2> Prints substituted segment values to the console: `{"room" => "livingroom"}` when receiving a message sent to the topic `myhome/livingroom/temperature`.

[[chapter:topic-based-messaging:publishing-a-retained-message]]
[discrete]
=== Publishing a Retained Message
The platform supports publishing a message as a _retained_ message. Retained messages help newly-subscribed clients to get the last message published to a topic immediately upon subscription. The broker stores one retained message per topic. To delete a retained message, send a retained message without a body to the topic. Deletion messages are not transported to subscribers.

The following example shows how to publish a message as a _retained_ message.

[source,typescript]
----
include::topic-based-communication.snippets.ts[tags=publish-retained-message]
----
<1> Sets the `retain` flag to `true`, instructing the message broker to store this message as a retained message.

[[chapter:topic-based-messaging:publishing-a-message-with-headers]]
[discrete]
=== Publishing a Message with Headers
The platform allows publishing a message with message headers, which the receiver then can read. A message header can contain any data that is serializable with the _Structured Clone Algorithm_.

[source,typescript]
----
include::topic-based-communication.snippets.ts[tags=publish-message-with-headers]
----
<1> Adds a custom message header.

'''

The recipient can then access the message headers via the `headers` property on the received message, as illustrated in the following example.

[source,typescript]
----
include::topic-based-communication.snippets.ts[tags=receive-message-with-headers]
----
<1> Prints received message headers to the console: `{"sensor-type" => "analog"}`.

[NOTE]
====
The platform adds some platform-specific headers to each message, like the message id or the publishing timestamp. Platform headers start with the Theta (`ɵ`) symbol. Some platform headers are public API and available to the application via the enum `MessageHeaders`.
 +
----
{"ɵMESSAGE_ID" => "8e53d603-ff12-400b-9d6e-8f41fbbe5f2b"}
{"ɵTIMESTAMP" => 1584124022134}
{"ɵAPP_SYMBOLIC_NAME" => "app-1"}
{"ɵCLIENT_ID" => "c8ce089f-10d7-4c82-b91e-11a7f60c15d3"}
----
====

[[chapter:topic-based-messaging:request-response-message-exchange-pattern]]
[discrete]
=== Request-Response Message Exchange
The platform facilitates the _request-response_ message exchange pattern for synchronous communication.

The communication is initiated by the publisher by sending a request (instead of publishing a message). The recipient can then respond to the request. Just as in JMS (_Java Message Service_), the platform sets a `ReplyTo` message header on the message, which contains the topic of a temporary inbox where the replier can send replies to. The inbox is destroyed when the publisher (requestor) unsubscribes.

The following code snippet shows how to initiate a _request-response_ communication and receiving replies.
[source,typescript]
----
include::topic-based-communication.snippets.ts[tags=request]
----
<1> Initiates a _request-response_ communication by invoking the `request$` method on the `MessageClient`.
<2> Prints the received replies to the console.

TIP: The `Observable` never completes. If expecting a single reply, use the `take(1)` RxJS operator to unsubscribe upon the receipt of the first reply.

'''

The following code snippet shows how to reply to a request. For illustrative purposes, when receiving a request, a subscription to the temperature sensor is created. The sensor Observable is a hot Observable, meaning it never completes and emits at every temperature change.

[source,typescript]
----
include::topic-based-communication.snippets.ts[tags=reply]
----
<1> Reads the `ReplyTo` topic from the request where to send replies to.
<2> Sends the temperature to the requestor.
<3> Stops replying when the requestor unsubscribes.

TIP: If streaming data like in the example above, the replier can use the RxJS `takeUntilUnsubscribe` operator of the platform to stop replying when the requestor unsubscribes.

